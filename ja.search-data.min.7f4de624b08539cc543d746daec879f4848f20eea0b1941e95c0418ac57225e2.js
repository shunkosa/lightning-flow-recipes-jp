'use strict';(function(){const b={encode:!1,tokenize:function(a){return a.replace(/[\x00-\x7F]/g,'').split('')}};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/lightning-flow-recipes-jp/big-deal-chatter-alerts/',title:"商談成立時に Chatter 投稿とフォローアップ ToDo を作成",section:"Lightning Flow Recipes",content:"使い方 #  フローを有効化し、金額が 1,000,000 円以上の商談を成立させると、そのレコードに Chatter 投稿され、ToDo が作成されます。\nポイント #  レコードトリガフロー #  レコードトリガーフローを用いると、ワークフロールールやプロセスビルダーのようにレコードの作成・変更を契機に処理を実行することができます。レコードトリガフローの特徴は、将来の機能追加が期待されていること、プロセスよりも処理が高速であること、削除を契機に処理が実行できたり、関連レコード以外のレコードも扱えるなど、高度な処理が実現できるところです。プロセスビルダーとの比較については、『レコードトリガフローの考慮事項』も参照してください。\nレコードトリガフローの開始要素では、プロセスビルダーと同様に、起動する条件やオブジェクトを選択できますが、この時点でオブジェクトのレコードを絞り込むこともできます。このフローでは、金額が 1,000,000 以上かつ成立している商談が対象であるため、ここで商談を絞り込むとフローがシンプルになります。ただし、開始要素での絞り込みには数式項目が利用できませんので注意してください。(この場合は通常通り[レコードを取得]要素を使用します。)\nChatter 投稿 #  フローから Chatter 投稿を行うには、[アクション] 要素で [Chatter に投稿] を選択します。\nこのアクションの必須項目は、[メッセージ] と [対象名または ID] の2つです。\n[メッセージ] は Chatter 投稿の本文です。 メンションする場合は、@[0051m000000Zw7] のように記載します。ユーザ ID は ID を直接指定するのではなく、変数にすることもできます。このフローでは、@[{!$Record.OwnerId}] 商談が成立しました！ というメッセージを設定して、対象の商談の所有者 (OwnerId) にメンションする設定になっています。ロングテキストや数式を利用する場合は、直接入力ではなく、テキストテンプレートを作成し、このアクションから参照すると良いでしょう。\n[対象名または ID] はどのレコードに対して Chatter 投稿するかを指定します。レコード ID を指定するか、ユーザ\u0008名やChatter グループ名を指定することもできます。ユーザ名を設定した場合は、[ターゲット種別] の項目に User を設定し、Chatter グループ名を指定した場合は、[ターゲット種別] の項目に Group を設定してください。詳細は Help 記事の フローコアアクション - Chatter に投稿 を参照してください。\n"}),a.add({id:1,href:'/lightning-flow-recipes-jp/disable-user-email-auto-bcc/',title:"ユーザ登録時にメールのBCC設定をオフにする",section:"Lightning Flow Recipes",content:"ユーザ登録時にメールのBCC設定をオフにするためのレコードトリガフロー(保存前フロー)です。\nこの項目はデフォルトでONになっていますが、このフローを有効化すると、登録時にOFFに設定されます。\nポイント #   保存前フローの基本的な内容については、『取引先の請求先住所を納入先住所に自動コピー』も合わせて確認してください。 同様の機能はプロセスビルダーや保存後フローでも実装できますが、実現したい処理が同じオブジェクトを更新するだけであれば、保存前フローの方が作りがシンプルになり、処理も高速です。  "}),a.add({id:2,href:'/lightning-flow-recipes-jp/mass-delete-leads/',title:"リストビューからリードを一括削除",section:"Lightning Flow Recipes",content:"リストビューからリードを一括削除するためのレコードトリガフローです。一括クイックアクション(リストビューの検索レイアウトで配置するクイックアクション)と併用します。\n使い方 #   フローを有効化します。 [オブジェクトマネージャ] \u0026gt; [リード] \u0026gt; [Salesforce Clasic の検索レイアウト] で、[リストビュー] を編集し、[Lightning Experience でのリストビューアクション] セクションで、[リードの削除] を追加します。  リストビューから任意のリードをチェックして、[リードの削除] ボタンをクリックします。  ポイント #  リストビューから直接フローを呼び出すことができないため、代わりにレコードの更新をトリガにフローを呼び出しています。また、このフローでは、削除対象のフローを特定するために、カスタムのチェックボックス項目を使用しています。\n"}),a.add({id:3,href:'/lightning-flow-recipes-jp/unsupported-features/',title:"レコードトリガフローの考慮事項",section:"Lightning Flow Recipes",content:"以下は Spring \u0026lsquo;21 時点の情報です。\n保存前フローの考慮事項 #   サブフロー、アクションが使用できない。 保存前フローでの値の更新により、保存後の自動化プロセス(ワークフロールールやプロセス、保存後フロー)が起動する。 親オブジェクトや子オブジェクトのレコードを更新できない。  保存前フローは、現在起動したオブジェクトのレコードの更新のみ対応しています。   Apex トリガと異なりカスタムのバリデーションエラーは発生させられない。  プロセスビルダーと比較した際のレコードトリガフローの考慮事項 #   承認プロセスのレコード更新アクションにより起動されない。 サブフローが使用できない。 ISCHANGED() や PRIORVALUE() 関数が使用できない。  $Record__Prior 変数が代替になります。   ISNEW() 関数が使用できない。  $Record.Id が null かどうかで代替できます。   時間ベースのアクションに相当する設定がない。  開始要素からは遅延実行が可能です    "}),a.add({id:4,href:'/lightning-flow-recipes-jp/design-guideline/',title:"実装時に気をつけると良いこと",section:"Lightning Flow Recipes",content:"Help に記載のベストプラクティス に可能な限り従ってください。\n命名規則 #  各要素の API 名には命名規則を設けることで保守性が高まります。このレシピでは一例として以下の命名規則を定めています。また、各要素の [説明] 欄には可能な限りその目的を入力しておきましょう。\n   要素 命名規則の例 API名の例     画面 screen_ で始める screen_LeadUpdate   画面の入力要素 input_ で始める input_FirstName   画面の表示要素 display_ で始める display_ErrorMessage   数式 formula_ で始める formula_Today   変数 var_ で始める\n(※recordId は例外) var_AccountId   決定 decision_ で始める decision_Profile   ループ loop_ で始める loop_Contacts   割り当て assign_ で始める assign_AccountShippingAddress   レコードを取得 ・get_ で始める\n・オブジェクト名を含める get_Opportunity   レコードを作成 ・create_ で始める\n・オブジェクト名を含める create_Lead   レコードを更新 ・update_ で始める\n・オブジェクト名を含める update_Contact   レコードを削除 ・delete_ で始める\n・オブジェクト名を含める delete_Account    主要なガバナ制約 #  フローやプロセスは、Apex トリガと異なり、自動で一括処理 (Bulkifiation) が考慮されますが、主要な制限に抵触しないように、実装時には以下に注意が必要です。\n フロー内で 1 度に実行できるレコードの操作には上限があるため、ループ内でのレコード操作を避け、コレクション変数を使用してレコードを操作してください。  詳細は Help 記事 を参照してください。   1 度に実行できるフロー要素の上限は 2000 のため、大きなコレクション変数をループする場合、この制限に抵触する可能性があります。ループ内のロジックを最適化できないか検討してください。  自動実行フローの場合は、[一時停止] 要素を使用することで処理を分けることができますが、このとき、フローの残りの部分は異なる処理で非同期に実行されます。    実行ユーザ #   Summer \u0026lsquo;20 から開始要素でフローの実行ユーザを細かく制御できるようになりました。 自動起動フローは、呼び出し元の実行ユーザを引き継ぎます。プロセスからフローを起動する場合、プロセスの実行はシステムコンテキストとなるため、呼び出されるフローの実行ユーザもシステムコンテキストとなります。  "}),a.add({id:5,href:'/lightning-flow-recipes-jp/mass-campaign-delete-by-admin-screen/',title:"システム管理者だけが自分が作成したキャンペーンを一括削除できる画面",section:"Lightning Flow Recipes",content:"プロファイルで表示する画面を分岐し、作成者が自身であるキャンペーンを一括削除するフローです。\nポイント #  フローを実行しているユーザの情報を取得する #  プロファイルやロールによって分岐を入れたい、実行ユーザが所有者のレコードを取得したい等、フロー内で実行ユーザの情報を取得するには、数式リソースを作成し、グローバル変数を参照します。このフローでは、実行ユーザのプロファイル名を取得するために $Profile.Name、実行ユーザの ID を取得するために $User.Id を使用しています。\n注: システム管理者プロファイルの名称は、組織やユーザの言語が英語の場合 System Administrator となります。必要に応じてフローまたは言語を変更してください。\n数式で利用可能なグローバル変数については、実際にフローの設定画面内でリソースを参照するか、Salesforce Help - フローのリソース: グローバル変数 を参照してください。項目については、標準オブジェクトのリファレンス (Profile, User, UserRole) を参照してください。\n"}),a.add({id:6,href:'/lightning-flow-recipes-jp/basic-login-flow/',title:"ログイン直後にお知らせメッセージを表示",section:"Lightning Flow Recipes",content:"ログインフローの例です。\n使い方 #   「ログインフロー用のサンプル画面」フローを有効化します。 [設定] - [ログインフロー] から、新しくログインフローを設定します。有効化したフローを選択してください。  ポイント #  ログインフローについて #  上記スクリーンショットの通り、ログインフローは、ログイン画面から Salesforce のアプリケーションに遷移する前に起動できるフローです。主なユースケースは、ログイン時のアナウンスや情報収集、高度な認証プロセスの実装等です。詳細は Salesforce Help - カスタムログインフロー を参照してください。\n設定時に気をつけること #  ログインフローの最中にエラーになるとログインできなくなる可能性がありますので、ログインフローで使用するフローは入念にテストしてください。また、万が一のために、リリース前にログインフローを解除できるユーザを用意しておきましょう。(例: システム管理者にはログインフローを設定しないか、設定にアクセスできログインフローが割り当たっていないプロファイルを用意しておく)\n"}),a.add({id:7,href:'/lightning-flow-recipes-jp/task-with-file-create-screen/',title:"ToDoとファイルの登録画面",section:"Lightning Flow Recipes",content:"新規 ToDo に続けてファイルをアップロードできる画面フローです。\nポイント #  ファイルのアップロード #  [ファイルのアップロード] 要素では、[関連レコード ID] 欄に、親レコードの ID を設定します。このコンポーネントでは、テキストなど通常の画面入力要素と異なり、[次へ] を押すことなく、コンポーネント上で直接ファイルをアップロードします。そのため、画面を開いた時点で [関連レコード ID] の値が確定していないとファイルのアップロードはできません。つまり、親レコードの作成とファイルのアップロードを同じ画面で行うことはできないことに注意してください。(レコードの更新とファイルのアップロードであれば、画面を開いた時点で親レコードの ID が確定しているので実装可能です。)\n"}),a.add({id:8,href:'/lightning-flow-recipes-jp/create-contact-update-case-from-web-or-email/',title:"Web-to-ケース/メール-to-ケースで取引先責任者を自動作成",section:"Lightning Flow Recipes",content:"Web-to-ケースまたはメール-to-ケースでケースを作成した場合、メールアドレスで取引先責任者が検索され、自動で紐付けされます。(参考: Salesforce Help - ケース登録時の関連付けについて) ただし、取引先責任者が見つからなかった場合は何も起こりません。このフローは、メールアドレスで取引先責任者を検索し、見つからなかった場合に取引先責任者を自動作成して紐付けします。\nSummer \u0026lsquo;20 より保存後フローが利用できるようになったため、プロセスを使用せずにフローだけで実装することができます。\n使い方 #   Web-to-ケースまたはメール-to-ケースを組織で有効化します。 フローを有効化します。 取引先責任者のメールアドレスとして組織にレコードが存在しないメールアドレスを使用して、Web−to-ケースまたはメール-to-ケースでケースを作成します。 作成されたケースに、新規作成された取引先責任者が紐付いていることを確認します。  "}),a.add({id:9,href:'/lightning-flow-recipes-jp/lead-update-screen/',title:"リードの更新画面",section:"Lightning Flow Recipes",content:"リードを更新するシンプルな画面フローです。\n使い方 #  フローを有効化後、このフローを使用してリードのクイックアクションを新規作成するか、リードの Lightning ページにフローを直接配置して使用することができます。デバッグする場合は recordId に任意のリードのレコードを選択してください。\nポイント #  Lightning ページやアクションからレコードを取得 #  現在開いているレコード Id をフロー内で取得するには [入力] にチェックの入った recordId という名前のレコード型の変数を用います。これまで、recordId は通常テキスト型の項目を用いて、フロー内で [レコードを取得] 要素を用いてレコード情報を取得していました。Summer \u0026lsquo;20 以降は、レコード型の変数を用いると、フロー内でレコードを取得し直す必要がなくなります。Lightning レコードページでフローを配置する際は、[レコードのすべての項目値をフロー変数に渡します] にチェックを入れてください。\n選択リストのデフォルト値 #  選択リストやラジオボタンで、現在開いているレコードの選択肢の値をデフォルト値に設定するには少し工夫が必要です。通常、オブジェクトの選択リスト項目を画面フローで使用する場合は、[選択リスト選択肢セット] を使用しますが、これ単独では現在開いているレコードの選択リスト値をデフォルト値として使用することができません。そこで、[レコード選択肢セット] を使用し、PicklistValueInfo オブジェクトから、現在開いている値以外の選択リスト値を取得します。加えて、現在開いているレコードの選択リスト値を個別の選択肢として作成し、これらを組み合わせます。\n数式 formula_CurrentLeadRatingLabel で表現している選択リスト値の表示ラベルは、環境に合わせて修正してください。\nレコードの更新 #  レコードを更新する際は、取引先の作成画面 のレコードの作成と同様に、個別に値を設定する方法と、レコード変数を使用する方法の 2 通りがあります。ここでは、一例としてレコード変数 recordId に値を割り当てた後、[レコードの更新] 要素でこのレコード変数を参照しています。個別に値を設定する方法でも更新できます。ぜひ試してみてください。\n"}),a.add({id:10,href:'/lightning-flow-recipes-jp/mass-email-to-contacts-screen/',title:"取引先から取引先責任者に一括メールを送信する画面",section:"Lightning Flow Recipes",content:"取引先に紐づく取引先責任者に対して固定の一括メールを送信するサンプルのフローです。条件分岐や、コレクション変数、ループの使い方を学べます。\n使い方 #  フローを有効化し、このフローを使用して取引先のクイックアクションを新規作成するか、取引先の Lightning ページにフローを配置します。デバッグで起動する場合は recordId に任意の取引先のレコードを選択してください。\nポイント #  [決定] 要素 #  このフローでは、取引先の[業種] に値が設定されているときだけ確認メッセージを表示しメール送信でき、値が設定されていない場合は、メールを送信できない旨のメッセージを表示する画面に遷移します。このように、フロー内で条件分岐を設定する場合には、[決定] 要素を使用します。\n[結果] の表示ラベルは、[決定] 要素と他の要素をつなぐ際、線の上に表示されますので、分かりやすい表示ラベルをつけるようにしましょう。\nコレクション変数 #  コレクション変数は、複数の値を保持することができる変数です。[レコードの取得] 要素で、すべてのレコードを選択した場合、その結果はコレクション変数として保存されます。このフローでは、(1つの) get_Contacts コレクション変数内に複数の取引先責任者レコード変数が含まれています。\nループ #  コレクション変数の中身を1つずつ取り出して処理を行いたい場合はループを用います。ループ要素の API 参照名 (ここでは loop_Contacts) は、コレクション変数に含まれる1つの変数を指しています。\nメール送信 #  フローからメールを送信する場合は、[アクション要素] から [メールを送信] を選択します。詳細は Salesforce Help - フローコアアクション: メールを送信 を参照してください。\nメール本文はアクションに直接記載するよりも、テキストテンプレートを使用すると良いでしょう。このとき、テキストテンプレートの種別はリッチテキストではなくテキストにします。(リッチテキストだと本文に HTML タグが挿入されてしまうため)\n"}),a.add({id:11,href:'/lightning-flow-recipes-jp/account-opportunity-create-screen/',title:"取引先と商談を1度に作成する画面",section:"Lightning Flow Recipes",content:"取引先と商談を1画面の入力内容から作成するフローです。\nポイント #  リレーションのあるレコードの作成 #  リレーションのあるレコードを作成する場合は、標準の画面から作成する場合と同様に、先に親オブジェクトのレコードを作成します。このフローでは、先に取引先を作成し続けて商談を作成します。\n[レコードの作成] 要素から、作成されたレコードの Id を変数として使用できます。このフローでは、商談の取引先 ID (AccountId) に対して、「取引先の作成」要素から生まれた 取引先 ID を割り当てています。これにより、作成される商談は、直前に作成された取引先を参照します。\n"}),a.add({id:12,href:'/lightning-flow-recipes-jp/account-create-screen/',title:"取引先の作成画面",section:"Lightning Flow Recipes",content:"取引先を新規作成するシンプルな画面フローです。\n使い方 #  フローを有効化後、このフローを使用してクイックアクションを新規作成するか、任意の Lightning ページにフローを直接配置して使用することができます。フロービルダーを開いて [デバッグ] から起動することも可能です。\nポイント #  レコードの作成 #  フローでレコードを処理するには、1. 項目値を個別にセットする (個別のリソースおよびリテラル値を使用)方法と、2. レコード変数・レコードコレクション変数を使用する (レコードからのすべての値を使用) 方法があります。このフローでは前者の、項目値を個別にセットする方法を使用しています。\n一方で、レコード変数は、オブジェクトの複数の項目とそれらの値を1つのかたまりとして管理します。Excel に例えると、項目値を個別セットする方法は、セルに1つずつ値を入力すること、レコード変数は1行そのもの管理するイメージです。レコード変数を用いても結局各項目の値を参照したり値を設定することになりますが、複数のレコードを管理したり、レコードを検索し取得する場合は、レコード変数を用いるため、それをそのまま更新する場合は、個別セットよりもレコード変数を用いた方が処理がしやすいです。\nこのフローで、新たにレコード変数を定義し、[割り当て] 要素で値をセットしてからそのレコード変数でレコードを作成することもできます。ぜひ試してみてください。また、リードの更新 フローでも、レコード変数を用いた比較的シンプルな画面フローを定義しています。こちらも参照してください。\n画面要素の動的な表示切り替え #  各画面要素の [コンポーネントの表示を設定] セクションでコンポーネントを表示するタイミングを設定することができます。このフローでは、[年間売上] は、[従業員数] が2000以上のときのみ表示される例を実装しています。\n必要な項目だけを画面に表示することができるため、画面がシンプルになります。ぜひ実際のフローでも使えるシーンがないか確認してみてください。\n"}),a.add({id:13,href:'/lightning-flow-recipes-jp/sync-account-billing-address-to-shipping-address/',title:"取引先の請求先住所を納入先住所に自動コピー",section:"Lightning Flow Recipes",content:"ポイント #  取引先の請求先住所を納入先住所に自動コピーするフローです。\n保存前フローについて #  Spring \u0026lsquo;20 で GA となった保存前フローはプロセスビルダーと同様に、レコードの作成や更新をきっかけとして起動する自動化プロセスです。プロセスビルダーと比較して処理が高速であることがメリットです。例えば、コンパイルサイズの非常に大きな数式を作成している場合は、このフローに置き換えるとメンテナンスしやすくなる可能性があるでしょう。\n保存前フローは、レコードトリガフローを作成し、[開始] 要素の [フローを実行] 欄で [レコードが保存される前] を選択することで利用できます。プロセスビルダーとの比較については、『レコードトリガフローの考慮事項』を参照してください。\n保存前フローの基礎 #  保存前フローでは、対象のレコードが $Record 変数で管理されます。レコードを更新する場合は、[レコードの更新] 要素の代わりに、[割り当て] 要素を使用して、この変数の項目に値を設定します。\n複合項目の取り扱い #  納入先住所や請求先住所は ShippingAddress、BillingAddress といった項目で管理されますが、これらは複合項目と呼ばれ、読み取り専用です。少し手間がかかりますが、値を割り当てる際は、元の項目群 (郵便番号 (ShippingPostalCode) や都道府県 (ShippingState) など) を個別に扱う必要があります。\n"}),a.add({id:14,href:'/lightning-flow-recipes-jp/contact-search-and-update-screen/',title:"取引先責任者の検索・更新画面",section:"Lightning Flow Recipes",content:"取引先責任者を名前で検索し、検索した取引先責任者のうちから、対象となるレコードを選択し、その取引先と説明欄を一括更新する画面フローです。\nポイント #  画面要素に入力チェックを適用する #  フローでは、姓・名を全角カナのみに制限しています。画面要素の [入力を検証] セクションから入力チェックを適用できます。\n使い方は通常の入力規則と同様です。REGEX 関数のサンプルについては、「Salesforce Help - 一般的なREGEX関数を用いた正規表現の検証」 や、「Qiita - form用正規表現判定/備忘」 等を参考にしてください。\nコレクション変数のサイズ (件数) を取得する #  コレクション変数のサイズを取得するには、数値型の変数を作成し、コレクション変数を割り当てます。これで数値型の変数に自動的にコレクション変数のサイズが割り当てられます。\n例えば、[レコードを取得] の結果であるコレクション変数 get_Contacts に取引先責任者が10件含まれている場合、変数 var_NumOfContacts の値は10になります。\n複数選択リスト (チェックボックスグループ) の選択結果を取得する #  通常、選択リストで選択された結果を保存するには、[レコード選択肢セット] や [選択リスト選択肢セット] の最後のセクションにある [項目値をさらに保存] を用いますが、これは最後に選択された値しか取得できませんので、複数選択リストやチェックボックスグループの場合は少し工夫が必要です。\n複数選択リストやチェックボックスグループの選択結果は、画面要素に ;  区切りで1つの長いテキストとして保存されます。このフローではチェックボックスグループで検索した取引先責任者から更新対象を選択しますが、例えば3件の取引先責任者を選択した場合、input_Contacts の中身は、0031k00000TI6KEAA1; 0031k00000TI6KEBB2; 0031k00000TI6KECC3 のようになります。この長い文字列はこのままでは使えませんので、順番に; 区切りの Id を取り出す必要があります。数式 formula_NextPicklistValue formula_RemainingPicklistValues はそれぞれ、この長いテキストから先頭の Id と残りの文字列を切り取ったものです。最初に input_Contacts の中身を別のテキスト変数 (var_SelectedContactIds) にコピーして、Id を 1つ取りだしながら、取り出した Id を削っていきます。つまり、フローのループでは次のように値が変化していきます。\n  ループ回数 var_SelectedContactIds formula_NextPicklistValue\n(先頭の値) formula_RemainingPicklistValues\n(残った値)   1回目 0031k00000TI6KEAA1; 0031k00000TI6KEBB2; 0031k00000TI6KECC3 0031k00000TI6KEAA1 0031k00000TI6KEBB2; 0031k00000TI6KECC3   2回目 00031k00000TI6KEBB2; 0031k00000TI6KECC3 00031k00000TI6KEBB2 0031k00000TI6KECC3   3回目 0031k00000TI6KECC3 0031k00000TI6KECC3    ループ内では合わせて、レコード変数への値の割り当てと、コレクション変数へのレコード変数の追加も行っていますので、ループが終わった時点では、選択された3件のレコード変数が、コレクション変数に追加されています。レコードの更新処理では、このコレクション変数を渡すだけで更新処理が完了します。\n"}),a.add({id:15,href:'/lightning-flow-recipes-jp/opportunity-and-contact-role-create-screen/',title:"商談と取引先責任者ロールを1度に作成する画面",section:"Lightning Flow Recipes",content:"商談と、その商談の取引先責任者のロール(最大2つまで)を1度に登録できる画面フローです。\nポイント #  ルックアップ 要素 #  [ルックアップ] 要素は、選択(入力)された レコードの ID と名前を変数として保持します。商談の取引先責任者のロール (OppotunityContactRole オブジェクト) は必須項目に取引先責任者 ID、商談 ID、ロールがありますが、取引先責任者には、ルックアップ要素のレコードID (lookup_Contact1.recordId や lookup_Contact2.recordId つまり取引先責任者レコードのID)を割り当て、商談 ID には新規作成した商談の ID を、ロールには画面で選択したロールを割り当てています。\nレコードコレクション変数 #  サンプルのフローのように割り当て要素を使用しなくても、直接 [レコードの作成] 要素を用いれば、取引先責任者ロールのレコードは作成できます。しかし、一般に同じオブジェクトのレコードを複数登録する場合は、レコードの作成を繰り返し行うのではなく、複数のレコードを1つのコレクション変数にまとめると、[レコードの作成] 要素の使用が1回で済むため、パフォーマンスが良くなります。\n"}),a.add({id:16,href:'/lightning-flow-recipes-jp/scheduled-task-email-reminder/',title:"毎朝9時に期日を過ぎた ToDo の所有者にメール通知するスケジュールフロー",section:"Lightning Flow Recipes",content:"ポイント #  スケジュールトリガフロー #  レポートのスケジューリングのように、決まった時間にフローを定期的に実行させるには、スケジュールトリガフローを使用します。新規フロー作成時に、 [スケジュールトリガフロー] を選択します。\nスケジュールトリガフローを選択した場合に、開始要素でオブジェクトやレコードを絞り込むことができますが、ここでの条件には変数が使用できません。つまり、今回のように、完了予定日と本日日付を比較したい場合など、動的な条件を使用してレコードを取得する場合は、別途 [レコードの取得] 要素を使用してください。\nメール送信 #  メール送信については、『取引先から取引先責任者に一括メールを送信する画面』の画面フローにも例があります。Winter \u0026lsquo;21 時点では、Lightning フローから直接メールテンプレートを参照することはできません。代替として、ワークフローメールアラートはフローからも呼び出し可能であるため、メールアラートを作成するか、『メール送信用のサードパーティアクション(英語)』を使用する方法があります。このフローでは簡便のためにプレーンテキストのテキストテンプレートを使用しています。\n"}),a.add({id:17,href:'/lightning-flow-recipes-jp/changelog/',title:"リリースノート",section:"Lightning Flow Recipes",content:"0.9.0 - 2021年3月21日 #   Spring \u0026lsquo;21 アップグレードに伴い API バージョンおよび説明の更新  0.8.0 - 2020年11月07日 #   Winter \u0026lsquo;21 アップグレードに伴い『レコードトリガフローの考慮事項』を更新 利用できる場合は自動レイアウトを使用し、ランタイムの API バージョンを 50.0 に更新 『リストビューからリードを一括削除』を追加 『ユーザ登録時の自動BCC設定を解除』を追加 『商談成立時に Chatter 投稿とフォローアップ ToDo を作成』を追加 『毎朝9時に完了予定日を過ぎた商談の所有者に Chatter でメンションするスケジュールフロー』を『毎朝9時に期日を過ぎた ToDo の所有者にメール通知するスケジュールフロー』に変更  0.7.0 - 2020年7月20日 #   Summer \u0026lsquo;20 から recordId 変数がテキストではなくレコード変数として扱えるようになったため、『リードの更新画面』と『取引先から取引先責任者へ一括メール送信する画面』 の レコードを取得 要素を省略  0.6.0 - 2020年7月19日 #   Web サイトのテーマを変更して検索機能を追加 Summer \u0026lsquo;20 からループ内変数を明示的に設定する必要がなくなったため、『毎朝9時に完了予定日を過ぎた商談の所有者に Chatter でメンションするスケジュールフロー』 と 『取引先から取引先責任者に一括メールを送信する画面』 の設定から独自のループ内変数を削除 Summer \u0026lsquo;20 から保存後フローが利用可能になったため、『Web-to-ケース/メール-to-ケースで取引先責任者を自動作成』の実装を保存後フローに変更し、プロセスビルダーを削除  保存後フローの例として、『特定の取引先のケースを一括削除する』 を追加   補足として 『実装時の注意事項』 と 『レコードトリガフローの考慮事項』を追加  0.5.0 - 2020年3月14日 #   『システム管理者だけが自分が作成したキャンペーンを一括削除できる画面』を追加 『ログイン直後にお知らせメッセージを表示』を追加  0.4.1 - 2020年3月1日 #   デフォルトの結果 の表示ラベルを修正  0.4.0 - 2020年3月1日 #   『取引先から取引先責任者に一括メールを送信する画面』を追加 『毎朝9時に完了予定日を過ぎた商談の所有者に Chatter でメンションするスケジュールフロー』を追加  "})})()